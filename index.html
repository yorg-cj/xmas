<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Gift Puzzle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #222;

      /* Christmas palette (tuned for legibility over both themes) */
      --xmas-green-fill: rgba(14, 143, 47, 0.95);
      --xmas-green-line: rgba(14, 143, 47, 0.95);

      --xmas-red-fill: rgba(217, 48, 48, 0.95);
      --xmas-red-line: rgba(217, 48, 48, 0.95);

      /* Selection is always Christmas green */
      --sel-fill: var(--xmas-green-fill);
      --sel-line: var(--xmas-green-line);

      /* Responsive sizing (prevents grid/border issues on mobile) */
      --grid-cols: 6;
      --cell: min(3rem, calc((92vw - 8px) / var(--grid-cols)));
    }

    body {
      margin: 0;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      transition: background 0.4s ease, color 0.4s ease;
      overflow-x: hidden;
    }

    @media (max-width: 420px) {
      body { padding: 1rem; }
    }

    /* THEMES -------------------------------------------------------- */
    body.cozy {
      background: radial-gradient(circle at top, #fffdf8 0, #f5f5fa 40%, #ececf5 100%);
      color: #222;
    }

    body.festive {
      background: linear-gradient(180deg, #123524 0%, #0b1d14 40%, #2a0a0a 100%);
      color: #f8f8f8;
    }

    body.festive p { color: #f8f8f8; }

    /* NYT-LIKE TITLE PILL ------------------------------------------- */
    .titlePill {
      width: min(520px, 92vw);
      border-radius: 18px;
      overflow: hidden;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(0,0,0,0.14);
      box-shadow: 0 10px 25px rgba(0,0,0,0.12);
      text-align: center;
      margin: 0.5rem 0 0.75rem;
    }

    .titlePill__kicker {
      font-size: 0.78rem;
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 0.45rem 0.75rem;
      background: rgba(120, 200, 215, 0.55);
      border-bottom: 1px solid rgba(0,0,0,0.08);
      color: #111;
    }

    .titlePill__title {
      margin: 0;
      padding: 0.85rem 1rem 0.95rem;
      font-size: 2.35rem;
      line-height: 1.05;
      color: #111;
    }

    body.festive .titlePill {
      background: rgba(10, 18, 14, 0.72);
      border-color: rgba(255,255,255,0.18);
      box-shadow: 0 12px 28px rgba(0,0,0,0.35);
    }

    body.festive .titlePill__kicker {
      background: rgba(120, 200, 215, 0.22);
      border-bottom-color: rgba(255,255,255,0.14);
      color: rgba(255,255,255,0.92);
    }

    body.festive .titlePill__title { color: #f8f8f8; }

    /* SNOWFALL ------------------------------------------------------ */
    #snow {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      overflow: hidden;
    }

    .flake {
      position: absolute;
      top: -10px;
      border-radius: 50%;
      background: #ffffff;
      animation-name: snow-fall;
      animation-timing-function: linear;
      animation-iteration-count: infinite;
    }

    @keyframes snow-fall {
      0% { transform: translateY(0) translateX(0); }
      100% { transform: translateY(110vh) translateX(15px); }
    }

    /* CONTROLS ------------------------------------------------------ */
    #themeToggle {
      margin-top: 0.25rem;
      margin-bottom: 0.75rem;
      border-radius: 999px;
      border: 1px solid #333;
      padding: 0.3rem 0.9rem;
      background: #ffffffaa;
      color: #222;
      font-size: 0.85rem;
      cursor: pointer;
      backdrop-filter: blur(4px);
      transition: background 0.2s, transform 0.1s, box-shadow 0.1s;
    }

    body.festive #themeToggle {
      background: #04130fbb;
      color: #f8f8f8;
      border-color: #f8f8f8aa;
    }

    #themeToggle:hover {
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      transform: translateY(-1px);
    }

    /* GAME LAYOUT --------------------------------------------------- */
    #game {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 0.5rem;
      width: 100%;
      max-width: 800px;
      position: relative;
      z-index: 1;
    }

    @media (min-width: 700px) {
      #game {
        flex-direction: row;
        align-items: flex-start;
      }
    }

    #grid {
      display: inline-block;
      border: 2px solid #333;
      border-radius: 8px;
      background: #fff;
      touch-action: none;
      box-shadow: 0 10px 25px rgba(0,0,0,0.18);
      position: relative;
      overflow: hidden;
      max-width: 92vw; /* ensures border never overflows viewport */
    }

    body.festive #grid {
      border-color: #f8f8f8;
      background: rgba(18, 25, 25, 0.94);
    }

    .row { display: flex; }

    .cell {
      width: var(--cell);
      height: var(--cell);
      display: flex;
      align-items: center;
      justify-content: center;

      border: 1px solid transparent; /* no gridlines */
      font-weight: 700;
      font-size: calc(var(--cell) * 0.46);

      cursor: pointer;
      user-select: none;
      box-sizing: border-box;
      transition: transform 0.08s;
      background: rgba(255,255,255,0.0);
      position: relative;
    }

    body.festive .cell { color: #f2f2f2; }

    .cell .letter { position: relative; z-index: 3; }

    /* Circle highlight */
    .cell::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      width: calc(var(--cell) * 0.70);
      height: calc(var(--cell) * 0.70);
      transform: translate(-50%, -50%);
      border-radius: 999px;
      background: transparent;
      z-index: 2;
      pointer-events: none;
      transition: background-color 0.12s ease, transform 0.08s ease;
    }

    .cell.selected::after { background: var(--sel-fill); }
    .cell.found-theme::after { background: var(--xmas-green-fill); }
    .cell.found-spanagram::after { background: var(--xmas-red-fill); }

    .cell.found-theme .letter,
    .cell.found-spanagram .letter {
      color: #ffffff;
      text-shadow: 0 1px 2px rgba(0,0,0,0.35);
    }

    @media (hover: hover) {
      .cell:not(.found-theme):not(.found-spanagram):hover::after { background: rgba(255,255,255,0.10); }
      body.cozy .cell:not(.found-theme):not(.found-spanagram):hover::after { background: rgba(0,0,0,0.05); }
    }

    /* PATH OVERLAY --------------------------------------------------- */
    #pathOverlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
    }

    /* Sidebar -------------------------------------------------------- */
    #sidebar {
      flex: 1;
      padding: 1rem;
      background: #ffffff;
      border-radius: 8px;
      border: 1px solid #ddd;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    body.festive #sidebar {
      background: rgba(0,0,0,0.35);
      border-color: rgba(255,255,255,0.35);
      color: #f8f8f8;
      backdrop-filter: blur(6px);
    }

    #sidebar h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-size: 1.1rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #555;
    }

    body.festive #sidebar h2 { color: #f0f0f0; }

    #controls {
      margin-top: 0.5rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    button {
      border-radius: 999px;
      border: 1px solid #333;
      padding: 0.35rem 0.9rem;
      background: #222;
      color: #fff;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background-color 0.12s, transform 0.08s, box-shadow 0.08s;
    }

    button.secondary {
      background: #fff;
      color: #222;
      border-color: #999;
    }

    body.festive button.secondary {
      background: #04130f;
      color: #f8f8f8;
      border-color: #f8f8f8aa;
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 1px 0 rgba(0,0,0,0.2) inset;
    }

    #message {
      margin-top: 0.75rem;
      min-height: 1.2rem;
      font-size: 0.95rem;
      color: #333;
    }

    #message.success { color: #0F8F2F; font-weight: 700; }
    #message.error { color: #D93030; }
    #message.neutral { color: #555; }
    body.festive #message { color: #f2f2f2; }

    #selectionText {
      margin-top: 0.6rem;
      font-size: 0.9rem;
      color: #444;
      word-break: break-word;
    }
    body.festive #selectionText { color: #e0e0e0; }
    #selectionText span { font-weight: 600; }

    /* REVEAL OVERLAY -------------------------------------------------- */
    #revealOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.35s ease;
      z-index: 10;
    }

    #revealOverlay.visible { opacity: 1; pointer-events: auto; }

    .reveal-card {
      background: #ffffff;
      color: #222;
      padding: 1.6rem 2.2rem;
      border-radius: 14px;
      max-width: 420px;
      text-align: center;
      box-shadow: 0 18px 40px rgba(0,0,0,0.45);
      transform: scale(0.8) translateY(20px);
      animation: pop-in 0.4s ease forwards;
      position: relative;
      overflow: hidden;
    }

    body.festive .reveal-card {
      background: #15231c;
      color: #fdfdfd;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .reveal-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(255,255,255,0.2), transparent 55%),
                  radial-gradient(circle at bottom right, rgba(255,255,255,0.18), transparent 55%);
      pointer-events: none;
    }

    @keyframes pop-in {
      from { opacity: 0; transform: scale(0.7) translateY(30px); }
      to { opacity: 1; transform: scale(1) translateY(0); }
    }

    .reveal-card h2 { margin-top: 0; margin-bottom: 0.4rem; }
    .reveal-card p { margin-top: 0.2rem; margin-bottom: 1rem; line-height: 1.4; }
    .reveal-card button { margin-top: 0.5rem; }

    /* Disable zooming gestures ONLY inside the puzzle grid */
    #grid, #grid .cell { touch-action: none; }
  </style>
</head>

<body>
  <div id="snow"></div>

  <div class="titlePill" aria-label="Today's theme header">
    <div class="titlePill__kicker">TODAY‚ÄôS THEME</div>
    <h1 class="titlePill__title">My Gift To You</h1>
  </div>

  <button id="themeToggle">Switch to Festive View</button>
  <!-- <p><strong>Theme: My Gift To You</strong></p> -->

  <div id="game">
    <div id="grid"></div>
    <aside id="sidebar">
      <h2>Selection</h2>
      <div id="controls">
        <button id="checkBtn">Check selection</button>
        <button id="clearBtn" class="secondary">Clear selection</button>
      </div>
      <div id="selectionText"></div>
      <div id="message" class="neutral"></div>
    </aside>
  </div>

  <div id="revealOverlay">
    <div class="reveal-card">
      <h2>Surprise! üéÅ</h2>
      <p>Your gift is a <strong>COZY GETAWAY</strong> ‚Äì February 28 - March 1, a cozy hotel stay to see Mason Jennings at the Egyptian Theater.</p>
      <p>Merry Christmas! I love you so much.</p>
      <button id="closeReveal">Close</button>
    </div>
  </div>

  <script>
    const gridLetters = [
      ['O','C','R','Y','J','E'],
      ['Z','P','A','K','T','N'],
      ['N','Y','G','C','I','N'],
      ['O','M','E','N','I','L'],
      ['S','A','T','G','S','E'],
      ['C','O','Y','A','H','T'],
      ['T','E','N','R','W','O'],
      ['R','A','C','A','A','Y'],
      ['I','Y','N','U','B','F'],
      ['T','P','G','E','R','E'],
    ];

    const spanagram = {
      id: 'SPANAGRAM',
      label: 'COZY GETAWAY',
      path: [
        [0,1], [0,0], [1,0], [2,1], [2,2],
        [3,2], [4,2], [5,3], [6,4], [7,4], [7,5],
      ],
    };

    const themeWords = [
      { id: 'MASON',      label: 'Mason',      path: [ [3,1],[4,1],[4,0],[3,0],[2,0] ] },
      { id: 'JENNINGS',   label: 'Jennings',   path: [ [0,4],[0,5],[1,5],[2,5],[3,4],[3,3],[4,3],[4,4] ] },
      { id: 'PARK_CITY',  label: 'Park City',  path: [ [1,1],[1,2],[0,2],[1,3],[2,3],[2,4],[1,4],[0,3] ] },
      { id: 'EGYPTIAN',   label: 'Egyptian',   path: [ [9,3],[9,2],[8,1],[9,1],[9,0],[8,0],[7,1],[8,2] ] },
      { id: 'FEBRUARY',   label: 'February',   path: [ [8,5],[9,5],[8,4],[9,4],[8,3],[7,3],[6,3],[5,2] ] },
      { id: 'CONCERT',    label: 'Concert',    path: [ [5,0],[5,1],[6,2],[7,2],[6,1],[7,0],[6,0] ] },
      { id: 'HOTEL',      label: 'Hotel',      path: [ [5,4],[6,5],[5,5],[4,5],[3,5] ] },
    ];

    const gridEl = document.getElementById('grid');

    // Strongly disable touch zoom gestures inside the grid (iOS double-tap)
    gridEl.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) e.preventDefault();
    }, { passive: false });

    const checkBtn = document.getElementById('checkBtn');
    const clearBtn = document.getElementById('clearBtn');
    const messageEl = document.getElementById('message');
    const selectionTextEl = document.getElementById('selectionText');
    const themeToggleBtn = document.getElementById('themeToggle');
    const revealOverlay = document.getElementById('revealOverlay');
    const closeRevealBtn = document.getElementById('closeReveal');
    const snowContainer = document.getElementById('snow');

    const rows = gridLetters.length;
    const cols = gridLetters[0].length;

    const cellEls = [];
    let isDragging = false;
    let currentPointerId = null;
    let selection = [];
    const selectionSet = new Set();

    const foundTheme = new Set();
    let spanagramFound = false;
    let revealShown = false;

    const foundThemePaths = [];
    let foundSpanPath = null;

    // --- SVG PATH OVERLAY -----------------------------------------------------
    let svg;
    let selectionLine;

    function lineColor(kind) {
      const cs = getComputedStyle(document.documentElement);
      if (kind === 'span') return cs.getPropertyValue('--xmas-red-line').trim();
      if (kind === 'theme') return cs.getPropertyValue('--xmas-green-line').trim();
      return cs.getPropertyValue('--sel-line').trim();
    }

    function initOverlay() {
      svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("id", "pathOverlay");
      svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      svg.setAttribute("preserveAspectRatio", "none");
      svg.style.width = "100%";
      svg.style.height = "100%";

      const foundGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      foundGroup.setAttribute("id", "foundGroup");
      svg.appendChild(foundGroup);

      selectionLine = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
      selectionLine.setAttribute("id", "selectionLine");
      selectionLine.setAttribute("fill", "none");
      selectionLine.setAttribute("stroke-linecap", "round");
      selectionLine.setAttribute("stroke-linejoin", "round");
      selectionLine.setAttribute("stroke", lineColor('selection'));
      svg.appendChild(selectionLine);

      gridEl.appendChild(svg);
    }

    function setViewBoxToGrid() {
      const gridRect = gridEl.getBoundingClientRect();
      svg.setAttribute("viewBox", `0 0 ${gridRect.width} ${gridRect.height}`);
      return gridRect;
    }

    function getStrokeWidth(gridRect) {
      // Match NYT-ish thickness relative to cell size
      if (!cellEls?.[0]?.[0]) return 14;
      const rect = cellEls[0][0].getBoundingClientRect();
      return Math.max(10, Math.min(18, rect.width * 0.34));
    }

    function pointsForPath(path, gridRect) {
      return path.map(([r,c]) => {
        const rect = cellEls[r][c].getBoundingClientRect();
        const cx = rect.left + rect.width/2 - gridRect.left;
        const cy = rect.top + rect.height/2 - gridRect.top;
        return `${cx},${cy}`;
      }).join(" ");
    }

    function renderFoundLines(strokeW) {
      const foundGroup = svg.querySelector("#foundGroup");
      foundGroup.innerHTML = "";

      const gridRect = gridEl.getBoundingClientRect();

      for (const item of foundThemePaths) {
        const pl = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        pl.setAttribute("fill", "none");
        pl.setAttribute("stroke-width", String(strokeW));
        pl.setAttribute("stroke-linecap", "round");
        pl.setAttribute("stroke-linejoin", "round");
        pl.setAttribute("stroke", lineColor('theme'));
        pl.setAttribute("points", pointsForPath(item.path, gridRect));
        foundGroup.appendChild(pl);
      }

      if (foundSpanPath) {
        const pl = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        pl.setAttribute("fill", "none");
        pl.setAttribute("stroke-width", String(strokeW));
        pl.setAttribute("stroke-linecap", "round");
        pl.setAttribute("stroke-linejoin", "round");
        pl.setAttribute("stroke", lineColor('span'));
        pl.setAttribute("points", pointsForPath(foundSpanPath, gridRect));
        foundGroup.appendChild(pl);
      }
    }

    function updateOverlay() {
      if (!svg || !selectionLine) return;
      const gridRect = setViewBoxToGrid();
      const strokeW = getStrokeWidth(gridRect);

      selectionLine.setAttribute("stroke-width", String(strokeW));
      selectionLine.setAttribute("stroke", lineColor('selection'));

      if (selection.length < 2) {
        selectionLine.setAttribute("points", "");
      } else {
        const pts = selection.map(p => {
          const rect = cellEls[p.r][p.c].getBoundingClientRect();
          const cx = rect.left + rect.width/2 - gridRect.left;
          const cy = rect.top + rect.height/2 - gridRect.top;
          return `${cx},${cy}`;
        }).join(" ");
        selectionLine.setAttribute("points", pts);
      }

      renderFoundLines(strokeW);
    }

    window.addEventListener("resize", updateOverlay);

    // --- UTILS ----------------------------------------------------------------
    function coordKey(r, c) { return `${r},${c}`; }

    function cellsEqualPath(selectionCoords, pathCoords) {
      if (selectionCoords.length !== pathCoords.length) return false;
      const forward = selectionCoords.every((p,i) => p[0]===pathCoords[i][0] && p[1]===pathCoords[i][1]);
      if (forward) return true;
      const reversed = [...pathCoords].reverse();
      return selectionCoords.every((p,i) => p[0]===reversed[i][0] && p[1]===reversed[i][1]);
    }

    function isAdjacent(a, b) {
      const dr = Math.abs(a.r - b.r);
      const dc = Math.abs(a.c - b.c);
      return dr <= 1 && dc <= 1 && !(dr === 0 && dc === 0);
    }

    function setMessage(text, type='neutral') {
      messageEl.textContent = text;
      messageEl.className = type;
    }

    function updateSelectionView() {
      if (selection.length === 0) {
        selectionTextEl.innerHTML = 'Current selection: <span>(none)</span>';
      } else {
        const letters = selection.map(p => gridLetters[p.r][p.c]).join('');
        selectionTextEl.innerHTML = 'Current selection: <span>' + letters + '</span>';
      }
      updateOverlay();
    }

    // --- SNOW CREATION --------------------------------------------------------
    function createSnowflakes(count = 60) {
      for (let i = 0; i < count; i++) {
        const flake = document.createElement('div');
        flake.className = 'flake';
        const size = 4 + Math.random() * 6;
        flake.style.width = size + 'px';
        flake.style.height = size + 'px';
        flake.style.left = Math.random() * 100 + '%';
        flake.style.opacity = (0.3 + Math.random() * 0.7).toFixed(2);
        const duration = 8 + Math.random() * 10;
        const delay = -Math.random() * 20;
        flake.style.animationDuration = duration + 's';
        flake.style.animationDelay = delay + 's';
        snowContainer.appendChild(flake);
      }
    }

    // --- GRID RENDER ----------------------------------------------------------
    function buildGrid() {
      // Ensure CSS knows how many columns we have for responsive sizing
      document.documentElement.style.setProperty('--grid-cols', String(cols));

      for (let r = 0; r < rows; r++) {
        const rowEl = document.createElement('div');
        rowEl.className = 'row';
        cellEls[r] = [];

        for (let c = 0; c < cols; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';

          const span = document.createElement('span');
          span.className = 'letter';
          span.textContent = gridLetters[r][c];
          cell.appendChild(span);

          cell.dataset.row = r;
          cell.dataset.col = c;

          cell.addEventListener('pointerdown', onCellDown);
          cell.addEventListener('pointerenter', onCellEnter);

          rowEl.appendChild(cell);
          cellEls[r][c] = cell;
        }
        gridEl.appendChild(rowEl);
      }

      document.addEventListener('pointerup', endDrag);
      document.addEventListener('pointercancel', endDrag);
      document.addEventListener('pointermove', onGlobalPointerMove);
    }

    // --- SELECTION MANAGEMENT -------------------------------------------------
    function clearSelection(keepMessage=true) {
      selection = [];
      selectionSet.clear();
      for (let row of cellEls) for (let cell of row) cell.classList.remove('selected');
      updateSelectionView();
      if (!keepMessage) setMessage('');
    }

    function handleTap(r, c) {
      const key = coordKey(r, c);
      const cell = cellEls[r][c];
      if (cell.classList.contains('found-theme') || cell.classList.contains('found-spanagram')) return;

      if (selection.length === 0) { addToSelection(r, c); return; }

      const last = selection[selection.length-1];
      const lastKey = coordKey(last.r, last.c);

      if (key === lastKey) { popLastSelection(); return; }
      if (selectionSet.has(key)) { truncateTo(r, c); return; }
      if (!isAdjacent(last, {r, c})) return;

      addToSelection(r, c);
    }

    function addToSelection(r, c) {
      const key = coordKey(r, c);
      selection.push({r,c});
      selectionSet.add(key);
      cellEls[r][c].classList.add('selected');
      updateSelectionView();
    }

    function popLastSelection() {
      const last = selection.pop();
      selectionSet.delete(coordKey(last.r,last.c));
      cellEls[last.r][last.c].classList.remove('selected');
      updateSelectionView();
    }

    function truncateTo(r, c) {
      const idx = selection.findIndex(p => p.r===r && p.c===c);
      for (let i = selection.length-1; i > idx; i--) {
        const {r:rr, c:cc} = selection[i];
        selectionSet.delete(coordKey(rr,cc));
        cellEls[rr][cc].classList.remove('selected');
      }
      selection = selection.slice(0, idx+1);
      updateSelectionView();
    }

    function tryAddOrBacktrackOnDrag(r, c) {
      const key = coordKey(r, c);
      const cell = cellEls[r][c];
      if (cell.classList.contains('found-theme') || cell.classList.contains('found-spanagram')) return;

      if (selection.length === 0) { addToSelection(r, c); return; }

      const last = selection[selection.length-1];
      const lastKey = coordKey(last.r, last.c);
      if (key === lastKey) return;

      if (selectionSet.has(key)) {
        if (selection.length >= 2) {
          const prev = selection[selection.length-2];
          if (prev.r === r && prev.c === c) popLastSelection();
        }
        return;
      }

      if (!isAdjacent(last, {r, c})) return;
      addToSelection(r, c);
    }

    // pointer handlers ---------------------------------------------------------
    function onCellDown(e) {
      e.preventDefault();
      const cell = e.currentTarget;
      isDragging = true;
      currentPointerId = e.pointerId;
      handleTap(+cell.dataset.row, +cell.dataset.col);
    }

    function onCellEnter(e) {
      if (!isDragging || e.pointerId !== currentPointerId) return;
      const cell = e.currentTarget;
      tryAddOrBacktrackOnDrag(+cell.dataset.row, +cell.dataset.col);
    }

    function onGlobalPointerMove(e) {
      if (!isDragging || (currentPointerId !== null && e.pointerId !== currentPointerId)) return;
      const el = document.elementFromPoint(e.clientX, e.clientY);
      if (!el) return;
      const cell = el.classList && el.classList.contains('cell') ? el : (el.closest ? el.closest('.cell') : null);
      if (!cell) return;
      tryAddOrBacktrackOnDrag(+cell.dataset.row, +cell.dataset.col);
    }

    function endDrag(e) {
      if (!isDragging || (currentPointerId !== null && e.pointerId !== currentPointerId)) return;
      isDragging = false;
      currentPointerId = null;
    }

    // --- MARKING FOUND WORDS --------------------------------------------------
    function markTheme(word) {
      for (let [r,c] of word.path) {
        cellEls[r][c].classList.remove('selected');
        cellEls[r][c].classList.add('found-theme');
      }
      foundTheme.add(word.id);
      foundThemePaths.push({ id: word.id, path: word.path });
      updateOverlay();
    }

    function markSpan() {
      for (let [r,c] of spanagram.path) {
        cellEls[r][c].classList.remove('selected');
        cellEls[r][c].classList.add('found-spanagram');
      }
      spanagramFound = true;
      foundSpanPath = spanagram.path;
      updateOverlay();
    }

    // --- REVEAL OVERLAY -------------------------------------------------------
    function showGiftReveal() {
      if (revealShown) return;
      revealShown = true;
      revealOverlay.classList.add('visible');
    }

    // --- CHECK LOGIC ----------------------------------------------------------
    function handleCheck() {
      if (selection.length === 0) {
        setMessage("Select letters by tapping or dragging.", "neutral");
        return;
      }

      const coords = selection.map(p => [p.r,p.c]);

      if (!spanagramFound && cellsEqualPath(coords, spanagram.path)) {
        markSpan();
        clearSelection();
        setMessage("You found the phrase describing your gift!", "success");
        checkWin();
        return;
      }

      for (let word of themeWords) {
        if (foundTheme.has(word.id)) continue;
        if (cellsEqualPath(coords, word.path)) {
          markTheme(word);
          clearSelection();
          setMessage("You found a hidden word!", "success");
          checkWin();
          return;
        }
      }

      clearSelection();
      setMessage("Not a hidden word ‚Äî try again!", "error");
    }

    function checkWin() {
      if (spanagramFound && foundTheme.size === themeWords.length) {
        setMessage("You solved the puzzle! Your gift is a COZY GETAWAY üéÅ", "success");
        showGiftReveal();
      }
    }

    // --- THEME TOGGLE ---------------------------------------------------------
    let currentTheme = 'cozy';

    function applyTheme() {
      document.body.classList.remove('cozy','festive');
      document.body.classList.add(currentTheme);
      themeToggleBtn.textContent = (currentTheme === 'cozy') ? "Switch to Festive View" : "Switch to Cozy View";
      updateOverlay();
    }

    themeToggleBtn.addEventListener('click', () => {
      currentTheme = (currentTheme === 'cozy') ? 'festive' : 'cozy';
      applyTheme();
    });

    closeRevealBtn.addEventListener('click', () => {
      revealOverlay.classList.remove('visible');
    });

    revealOverlay.addEventListener('click', (e) => {
      if (e.target === revealOverlay) revealOverlay.classList.remove('visible');
    });

    // --- INIT -----------------------------------------------------------------
    createSnowflakes(70);
    buildGrid();
    initOverlay();
    currentTheme = 'cozy';
    applyTheme();
    updateSelectionView();
    setMessage('Tap or drag to select letters, then tap "Check selection".', 'neutral');

    checkBtn.addEventListener('click', handleCheck);
    clearBtn.addEventListener('click', () => clearSelection(false));

    // After first layout, ensure overlay lines are correctly positioned
    requestAnimationFrame(() => updateOverlay());
  </script>
</body>
</html>
