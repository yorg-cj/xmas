<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Gift Puzzle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #222;
    }

    body {
      margin: 0;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      transition: background 0.4s ease, color 0.4s ease;
    }

    /* THEMES -------------------------------------------------------- */
    body.cozy {
      background: radial-gradient(circle at top, #fffdf8 0, #f5f5fa 40%, #ececf5 100%);
      color: #222;
    }

    body.festive {
      background: linear-gradient(180deg, #123524 0%, #0b1d14 40%, #2a0a0a 100%);
      color: #f8f8f8;
    }

    body.festive h1,
    body.festive p {
      color: #f8f8f8;
    }

    /* SNOWFALL ------------------------------------------------------ */
    #snow {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      overflow: hidden;
    }

    .flake {
      position: absolute;
      top: -10px;
      border-radius: 50%;
      background: #ffffff;
      animation-name: snow-fall;
      animation-timing-function: linear;
      animation-iteration-count: infinite;
    }

    @keyframes snow-fall {
      0% {
        transform: translateY(0) translateX(0);
      }
      100% {
        transform: translateY(110vh) translateX(15px);
      }
    }

    /* LAYOUT -------------------------------------------------------- */
    h1 {
      margin-bottom: 0.25rem;
    }

    #themeToggle {
      margin-top: 0.25rem;
      margin-bottom: 0.75rem;
      border-radius: 999px;
      border: 1px solid #333;
      padding: 0.3rem 0.9rem;
      background: #ffffffaa;
      color: #222;
      font-size: 0.85rem;
      cursor: pointer;
      backdrop-filter: blur(4px);
      transition: background 0.2s, transform 0.1s, box-shadow 0.1s;
    }

    body.festive #themeToggle {
      background: #04130fbb;
      color: #f8f8f8;
      border-color: #f8f8f8aa;
    }

    #themeToggle:hover {
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      transform: translateY(-1px);
    }

    #game {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 0.5rem;
      width: 100%;
      max-width: 800px;
      position: relative;
      z-index: 1;
    }

    @media (min-width: 700px) {
      #game {
        flex-direction: row;
        align-items: flex-start;
      }
    }

    #grid {
      display: inline-block;
      border: 2px solid #333;
      border-radius: 8px;
      background: #fff;
      touch-action: none;
      box-shadow: 0 10px 25px rgba(0,0,0,0.18);
    }

    body.festive #grid {
      border-color: #f8f8f8;
      background: rgba(18, 25, 25, 0.94);
    }

    .row {
      display: flex;
    }

    .cell {
      width: 3rem;
      height: 3rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #ccc;
      font-weight: 700;
      font-size: 1.4rem;
      cursor: pointer;
      user-select: none;
      box-sizing: border-box;
      transition: background-color 0.12s, transform 0.08s, box-shadow 0.12s, border-radius 0.12s;
      background: rgba(255,255,255,0.95);
    }

    body.festive .cell {
      border-color: #55605d;
      background: rgba(12, 22, 22, 0.95);
      color: #f2f2f2;
    }

    .cell.selected {
      background: #d7e7ff;
      transform: scale(1.04);
    }

    body.festive .cell.selected {
      background: #203c5a;
    }

    /* ornament hover (only on non-found cells) */
    @media (hover: hover) {
      .cell:not(.found-theme):not(.found-spanagram):hover {
        border-radius: 999px;
        box-shadow: 0 6px 12px rgba(0,0,0,0.25);
        background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.9), #d7e7ff);
        transform: translateY(-2px) scale(1.05);
      }

      body.festive .cell:not(.found-theme):not(.found-spanagram):hover {
        background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.8), #203c5a);
      }
    }

    /* CHRISTMAS colors for found words --------------------------------- */
    .cell.found-theme {
      background: #0F8F2F !important;
      color: white;
    }

    .cell.found-spanagram {
      background: #D93030 !important;
      color: white;
    }

    .cell.found-theme.selected,
    .cell.found-spanagram.selected {
      box-shadow: 0 0 0 2px rgba(255,255,255,0.5) inset;
    }

    #sidebar {
      flex: 1;
      padding: 1rem;
      background: #ffffff;
      border-radius: 8px;
      border: 1px solid #ddd;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    body.festive #sidebar {
      background: rgba(0,0,0,0.35);
      border-color: rgba(255,255,255,0.35);
      color: #f8f8f8;
      backdrop-filter: blur(6px);
    }

    #sidebar h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-size: 1.1rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #555;
    }

    body.festive #sidebar h2 {
      color: #f0f0f0;
    }

    #controls {
      margin-top: 0.5rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    button {
      border-radius: 999px;
      border: 1px solid #333;
      padding: 0.35rem 0.9rem;
      background: #222;
      color: #fff;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background-color 0.12s, transform 0.08s, box-shadow 0.08s;
    }

    button.secondary {
      background: #fff;
      color: #222;
      border-color: #999;
    }

    body.festive button.secondary {
      background: #04130f;
      color: #f8f8f8;
      border-color: #f8f8f8aa;
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 1px 0 rgba(0,0,0,0.2) inset;
    }

    #message {
      margin-top: 0.75rem;
      min-height: 1.2rem;
      font-size: 0.95rem;
      color: #333;
    }

    #message.success {
      color: #0F8F2F;
      font-weight: 700;
    }

    #message.error {
      color: #D93030;
    }

    #message.neutral {
      color: #555;
    }

    body.festive #message {
      color: #f2f2f2;
    }

    /* current selection view */
    #selectionText {
      margin-top: 0.6rem;
      font-size: 0.9rem;
      color: #444;
      word-break: break-word;
    }

    body.festive #selectionText {
      color: #e0e0e0;
    }

    #selectionText span {
      font-weight: 600;
    }

    /* REVEAL OVERLAY -------------------------------------------------- */
    #revealOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.35s ease;
      z-index: 10;
    }

    #revealOverlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .reveal-card {
      background: #ffffff;
      color: #222;
      padding: 1.6rem 2.2rem;
      border-radius: 14px;
      max-width: 420px;
      text-align: center;
      box-shadow: 0 18px 40px rgba(0,0,0,0.45);
      transform: scale(0.8) translateY(20px);
      animation: pop-in 0.4s ease forwards;
      position: relative;
      overflow: hidden;
    }

    body.festive .reveal-card {
      background: #15231c;
      color: #fdfdfd;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .reveal-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(255,255,255,0.2), transparent 55%),
                  radial-gradient(circle at bottom right, rgba(255,255,255,0.18), transparent 55%);
      pointer-events: none;
    }

    @keyframes pop-in {
      from {
        opacity: 0;
        transform: scale(0.7) translateY(30px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .reveal-card h2 {
      margin-top: 0;
      margin-bottom: 0.4rem;
    }

    .reveal-card p {
      margin-top: 0.2rem;
      margin-bottom: 1rem;
      line-height: 1.4;
    }

    .reveal-card button {
      margin-top: 0.5rem;
    }

    /* Disable zooming gestures ONLY inside the puzzle grid */
    #grid {
      touch-action: none;
    }
  </style>
</head>
<body>
  <!-- Snow background -->
  <div id="snow"></div>

  <h1>Gift Puzzle</h1>
  <button id="themeToggle">Switch to Festive Theme</button>
  <p><strong>Theme: My Gift To You</strong> ‚Äî Tap or drag across adjacent letters (including diagonals) to form hidden words. Tap "Check selection" to see if you found one.</p>

  <div id="game">
    <div id="grid"></div>
    <aside id="sidebar">
      <h2>Selection</h2>
      <div id="controls">
        <button id="checkBtn">Check selection</button>
        <button id="clearBtn" class="secondary">Clear selection</button>
      </div>
      <div id="selectionText"></div>
      <div id="message" class="neutral"></div>
    </aside>
  </div>

  <!-- Gift reveal overlay -->
  <div id="revealOverlay">
    <div class="reveal-card">
      <h2>Surprise! üéÅ</h2>
      <p>Your gift is a <strong>COZY GETAWAY</strong> ‚Äì think Park City, a hotel stay, and a concert at the Egyptian in February.</p>
      <p>Thank you for being you. Merry Christmas.</p>
      <button id="closeReveal">Close</button>
    </div>
  </div>

  <script>
¬†¬†// --- DATA -----------------------------------------------------------------
¬†¬†const gridLetters = [
¬†¬†¬†¬†['E','G','I','F','S','A','M','A','P'],
¬†¬†¬†¬†['P','G','N','O','P','T','R','O','C'],
¬†¬†¬†¬†['T','Y','R','N','A','C','R','K','I'],
¬†¬†¬†¬†['S','I','A','L','N','O','E','T','Y'],
¬†¬†¬†¬†['C','O','Z','Y','G','T','C','A','Y'],
¬†¬†¬†¬†['S','N','O','W','E','T','A','W','T'],
¬†¬†¬†¬†['H','O','S','T','O','E','J','A','R'],
¬†¬†¬†¬†['T','L','A','G','N','N','U','F','Y'],
¬†¬†¬†¬†['E','T','R','I','N','I','R','B','E'],
¬†¬†];

¬†¬†const spanagram = {
¬†¬†¬†¬†id: 'SPANAGRAM',
¬†¬†¬†¬†label: 'COZY GETAWAY',
¬†¬†¬†¬†path: [
¬†¬†¬†¬†¬†¬†[4,0],[4,1],[4,2],[4,3],[4,4],
¬†¬†¬†¬†¬†¬†[5,4],[5,5],[5,6],[5,7],[4,7],[4,8],
¬†¬†¬†¬†],
¬†¬†};

¬†¬†const themeWords = [
¬†¬†¬†¬†{ id: 'MASON',¬†¬†¬†¬†¬†label: 'Mason',¬†¬†¬†¬†¬†path: [ [0,6],[0,5],[0,4],[1,3],[1,2] ] },
¬†¬†¬†¬†{ id: 'HOTEL',¬†¬†¬†¬†¬†label: 'Hotel',¬†¬†¬†¬†¬†path: [ [6,0],[6,1],[7,0],[8,0],[7,1] ] },
¬†¬†¬†¬†{ id: 'CONCERT',¬†¬†¬†label: 'Concert',¬†¬†¬†path: [ [4,6],[3,5],[3,4],[2,5],[3,6],[2,6],[1,5] ] },
¬†¬†¬†¬†{ id: 'PARK_CITY', label: 'Park City', path: [ [0,8],[0,7],[1,6],[2,7],[1,8],[2,8],[3,7],[3,8] ] },
¬†¬†¬†¬†{ id: 'EGYPTIAN',¬†¬†label: 'Egyptian',¬†¬†path: [ [0,0],[1,1],[2,1],[1,0],[2,0],[3,1],[3,2],[2,3] ] },
¬†¬†¬†¬†{ id: 'FEBRUARY',¬†¬†label: 'February',¬†¬†path: [ [7,7],[8,8],[8,7],[8,6],[7,6],[6,7],[6,8],[7,8] ] },
¬†¬†¬†¬†{ id: 'JENNINGS',¬†¬†label: 'Jennings',¬†¬†path: [ [6,6],[6,5],[7,5],[7,4],[8,5],[8,4],[7,3],[6,2] ] },
¬†¬†];

¬†¬†// --- STATE / ELEMENTS -----------------------------------------------------
¬†¬†const gridEl = document.getElementById('grid');
¬†¬†const checkBtn = document.getElementById('checkBtn');
¬†¬†const clearBtn = document.getElementById('clearBtn');
¬†¬†const messageEl = document.getElementById('message');
¬†¬†const selectionTextEl = document.getElementById('selectionText');
¬†¬†const themeToggleBtn = document.getElementById('themeToggle');
¬†¬†const revealOverlay = document.getElementById('revealOverlay');
¬†¬†const closeRevealBtn = document.getElementById('closeReveal');
¬†¬†const snowContainer = document.getElementById('snow');

¬†¬†const rows = gridLetters.length;
¬†¬†const cols = gridLetters[0].length;

¬†¬†const cellEls = [];
¬†¬†let isDragging = false;
¬†¬†let currentPointerId = null;
¬†¬†let selection = [];
¬†¬†const selectionSet = new Set();

¬†¬†const foundTheme = new Set();
¬†¬†let spanagramFound = false;
¬†¬†let revealShown = false;

¬†¬†// --- UTILS ----------------------------------------------------------------
¬†¬†function coordKey(r, c) { return `${r},${c}`; }

¬†¬†function cellsEqualPath(selectionCoords, pathCoords) {
¬†¬†¬†¬†if (selectionCoords.length !== pathCoords.length) return false;
¬†¬†¬†¬†const forward = selectionCoords.every((p,i) => p[0]===pathCoords[i][0] && p[1]===pathCoords[i][1]);
¬†¬†¬†¬†if (forward) return true;
¬†¬†¬†¬†const reversed = [...pathCoords].reverse();
¬†¬†¬†¬†return selectionCoords.every((p,i) => p[0]===reversed[i][0] && p[1]===reversed[i][1]);
¬†¬†}

¬†¬†function isAdjacent(a, b) {
¬†¬†¬†¬†const dr = Math.abs(a.r - b.r);
¬†¬†¬†¬†const dc = Math.abs(a.c - b.c);
¬†¬†¬†¬†return dr <= 1 && dc <= 1 && !(dr === 0 && dc === 0);
¬†¬†}

¬†¬†function setMessage(text, type='neutral') {
¬†¬†¬†¬†messageEl.textContent = text;
¬†¬†¬†¬†messageEl.className = type;
¬†¬†}

¬†¬†function updateSelectionView() {
¬†¬†¬†¬†if (selection.length === 0) {
¬†¬†¬†¬†¬†¬†selectionTextEl.innerHTML = 'Current selection: <span>(none)</span>';
¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†}
¬†¬†¬†¬†const letters = selection.map(p => gridLetters[p.r][p.c]).join('');
¬†¬†¬†¬†selectionTextEl.innerHTML = 'Current selection: <span>' + letters + '</span>';
¬†¬†}

¬†¬†// --- SNOW CREATION --------------------------------------------------------
¬†¬†function createSnowflakes(count = 60) {
¬†¬†¬†¬†for (let i = 0; i < count; i++) {
¬†¬†¬†¬†¬†¬†const flake = document.createElement('div');
¬†¬†¬†¬†¬†¬†flake.className = 'flake';
¬†¬†¬†¬†¬†¬†const size = 4 + Math.random() * 6;
¬†¬†¬†¬†¬†¬†flake.style.width = size + 'px';
¬†¬†¬†¬†¬†¬†flake.style.height = size + 'px';
¬†¬†¬†¬†¬†¬†flake.style.left = Math.random() * 100 + '%';
¬†¬†¬†¬†¬†¬†flake.style.opacity = (0.3 + Math.random() * 0.7).toFixed(2);
¬†¬†¬†¬†¬†¬†const duration = 8 + Math.random() * 10;
¬†¬†¬†¬†¬†¬†const delay = -Math.random() * 20;
¬†¬†¬†¬†¬†¬†flake.style.animationDuration = duration + 's';
¬†¬†¬†¬†¬†¬†flake.style.animationDelay = delay + 's';
¬†¬†¬†¬†¬†¬†snowContainer.appendChild(flake);
¬†¬†¬†¬†}
¬†¬†}

¬†¬†// --- GRID RENDER ----------------------------------------------------------
¬†¬†function buildGrid() {
¬†¬†¬†¬†for (let r = 0; r < rows; r++) {
¬†¬†¬†¬†¬†¬†const rowEl = document.createElement('div');
¬†¬†¬†¬†¬†¬†rowEl.className = 'row';

¬†¬†¬†¬†¬†¬†cellEls[r] = [];

¬†¬†¬†¬†¬†¬†for (let c = 0; c < cols; c++) {
¬†¬†¬†¬†¬†¬†¬†¬†const cell = document.createElement('div');
¬†¬†¬†¬†¬†¬†¬†¬†cell.className = 'cell';
¬†¬†¬†¬†¬†¬†¬†¬†cell.textContent = gridLetters[r][c];
¬†¬†¬†¬†¬†¬†¬†¬†cell.dataset.row = r;
¬†¬†¬†¬†¬†¬†¬†¬†cell.dataset.col = c;

¬†¬†¬†¬†¬†¬†¬†¬†cell.addEventListener('pointerdown', onCellDown);
¬†¬†¬†¬†¬†¬†¬†¬†// we keep pointerenter for mouse; touch uses global pointermove
¬†¬†¬†¬†¬†¬†¬†¬†cell.addEventListener('pointerenter', onCellEnter);

¬†¬†¬†¬†¬†¬†¬†¬†rowEl.appendChild(cell);
¬†¬†¬†¬†¬†¬†¬†¬†cellEls[r][c] = cell;
¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†¬†¬†gridEl.appendChild(rowEl);
¬†¬†¬†¬†}

¬†¬†¬†¬†document.addEventListener('pointerup', endDrag);
¬†¬†¬†¬†document.addEventListener('pointercancel', endDrag);
¬†¬†¬†¬†document.addEventListener('pointermove', onGlobalPointerMove);
¬†¬†}

¬†¬†// --- SELECTION MANAGEMENT -------------------------------------------------
¬†¬†function clearSelection(keepMessage=true) {
¬†¬†¬†¬†selection = [];
¬†¬†¬†¬†selectionSet.clear();
¬†¬†¬†¬†for (let row of cellEls) {
¬†¬†¬†¬†¬†¬†for (let cell of row) {
¬†¬†¬†¬†¬†¬†¬†¬†cell.classList.remove('selected');
¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†}
¬†¬†¬†¬†updateSelectionView();
¬†¬†¬†¬†if (!keepMessage) setMessage('');
¬†¬†}

¬†¬†function handleTap(r, c) {
¬†¬†¬†¬†const key = coordKey(r, c);
¬†¬†¬†¬†const cell = cellEls[r][c];

¬†¬†¬†¬†if (cell.classList.includes && (cell.classList.contains('found-theme') || cell.classList.contains('found-spanagram'))) {
¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†}
¬†¬†¬†¬†if (cell.classList.contains('found-theme') || cell.classList.contains('found-spanagram')) {
¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†}

¬†¬†¬†¬†if (selection.length === 0) {
¬†¬†¬†¬†¬†¬†addToSelection(r, c);
¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†}

¬†¬†¬†¬†const last = selection[selection.length-1];
¬†¬†¬†¬†const lastKey = coordKey(last.r, last.c);

¬†¬†¬†¬†// Tap last again to undo it
¬†¬†¬†¬†if (key === lastKey) {
¬†¬†¬†¬†¬†¬†popLastSelection();
¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†}

¬†¬†¬†¬†// Tap earlier cell in path => backtrack (truncate) to it
¬†¬†¬†¬†if (selectionSet.has(key)) {
¬†¬†¬†¬†¬†¬†truncateTo(r, c);
¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†}

¬†¬†¬†¬†// Add new cell: must be adjacent
¬†¬†¬†¬†if (!isAdjacent(last, {r, c})) return;

¬†¬†¬†¬†addToSelection(r, c);
¬†¬†}

¬†¬†function addToSelection(r, c) {
¬†¬†¬†¬†const key = coordKey(r, c);
¬†¬†¬†¬†selection.push({r,c});
¬†¬†¬†¬†selectionSet.add(key);
¬†¬†¬†¬†cellEls[r][c].classList.add('selected');
¬†¬†¬†¬†updateSelectionView();
¬†¬†}

¬†¬†function popLastSelection() {
¬†¬†¬†¬†const last = selection.pop();
¬†¬†¬†¬†const key = coordKey(last.r,last.c);
¬†¬†¬†¬†selectionSet.delete(key);
¬†¬†¬†¬†cellEls[last.r][last.c].classList.remove('selected');
¬†¬†¬†¬†updateSelectionView();
¬†¬†}

¬†¬†function truncateTo(r, c) {
¬†¬†¬†¬†const idx = selection.findIndex(p => p.r===r && p.c===c);
¬†¬†¬†¬†for (let i = selection.length-1; i > idx; i--) {
¬†¬†¬†¬†¬†¬†const {r:rr, c:cc} = selection[i];
¬†¬†¬†¬†¬†¬†selectionSet.delete(coordKey(rr,cc));
¬†¬†¬†¬†¬†¬†cellEls[rr][cc].classList.remove('selected');
¬†¬†¬†¬†}
¬†¬†¬†¬†selection = selection.slice(0, idx+1);
¬†¬†¬†¬†updateSelectionView();
¬†¬†}

¬†¬†// Drag add/backtrack (used by pointerenter + global pointermove)
¬†¬†function tryAddOrBacktrackOnDrag(r, c) {
¬†¬†¬†¬†const key = coordKey(r, c);
¬†¬†¬†¬†const cell = cellEls[r][c];

¬†¬†¬†¬†if (cell.classList.contains('found-theme') || cell.classList.contains('found-spanagram')) return;

¬†¬†¬†¬†if (selection.length === 0) {
¬†¬†¬†¬†¬†¬†addToSelection(r, c);
¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†}

¬†¬†¬†¬†const last = selection[selection.length-1];
¬†¬†¬†¬†const lastKey = coordKey(last.r, last.c);
¬†¬†¬†¬†if (key === lastKey) return;

¬†¬†¬†¬†// Backtrack one step if this is the previous cell
¬†¬†¬†¬†if (selectionSet.has(key)) {
¬†¬†¬†¬†¬†¬†if (selection.length >= 2) {
¬†¬†¬†¬†¬†¬†¬†¬†const prev = selection[selection.length-2];
¬†¬†¬†¬†¬†¬†¬†¬†if (prev.r === r && prev.c === c) {
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†popLastSelection();
¬†¬†¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†}

¬†¬†¬†¬†if (!isAdjacent(last, {r, c})) return;

¬†¬†¬†¬†addToSelection(r, c);
¬†¬†}

¬†¬†// pointer handlers ---------------------------------------------------------
¬†¬†function onCellDown(e) {
¬†¬†¬†¬†e.preventDefault();
¬†¬†¬†¬†const cell = e.currentTarget;
¬†¬†¬†¬†const r = +cell.dataset.row;
¬†¬†¬†¬†const c = +cell.dataset.col;
¬†¬†¬†¬†isDragging = true;
¬†¬†¬†¬†currentPointerId = e.pointerId;
¬†¬†¬†¬†// treat as tap (click) as well
¬†¬†¬†¬†handleTap(r, c);
¬†¬†}

¬†¬†function onCellEnter(e) {
¬†¬†¬†¬†// This is mainly for mouse; touch will use onGlobalPointerMove
¬†¬†¬†¬†if (!isDragging || e.pointerId !== currentPointerId) return;
¬†¬†¬†¬†const cell = e.currentTarget;
¬†¬†¬†¬†const r = +cell.dataset.row;
¬†¬†¬†¬†const c = +cell.dataset.col;
¬†¬†¬†¬†tryAddOrBacktrackOnDrag(r, c);
¬†¬†}

¬†¬†function onGlobalPointerMove(e) {
¬†¬†¬†¬†if (!isDragging || (currentPointerId !== null && e.pointerId !== currentPointerId)) return;

¬†¬†¬†¬†// Use elementFromPoint so touch drag works across cells
¬†¬†¬†¬†const el = document.elementFromPoint(e.clientX, e.clientY);
¬†¬†¬†¬†if (!el || !el.classList || !el.classList.contains('cell')) return;

¬†¬†¬†¬†const r = +el.dataset.row;
¬†¬†¬†¬†const c = +el.dataset.col;
¬†¬†¬†¬†tryAddOrBacktrackOnDrag(r, c);
¬†¬†}

¬†¬†function endDrag(e) {
¬†¬†¬†¬†if (!isDragging || (currentPointerId !== null && e.pointerId !== currentPointerId)) return;
¬†¬†¬†¬†isDragging = false;
¬†¬†¬†¬†currentPointerId = null;
¬†¬†}

¬†¬†// --- MARKING FOUND WORDS --------------------------------------------------
¬†¬†function markTheme(word) {
¬†¬†¬†¬†for (let [r,c] of word.path) {
¬†¬†¬†¬†¬†¬†cellEls[r][c].classList.remove('selected');
¬†¬†¬†¬†¬†¬†cellEls[r][c].classList.add('found-theme');
¬†¬†¬†¬†}
¬†¬†¬†¬†foundTheme.add(word.id);
¬†¬†}

¬†¬†function markSpan() {
¬†¬†¬†¬†for (let [r,c] of spanagram.path) {
¬†¬†¬†¬†¬†¬†cellEls[r][c].classList.remove('selected');
¬†¬†¬†¬†¬†¬†cellEls[r][c].classList.add('found-spanagram');
¬†¬†¬†¬†}
¬†¬†¬†¬†spanagramFound = true;
¬†¬†}

¬†¬†// --- REVEAL OVERLAY -------------------------------------------------------
¬†¬†function showGiftReveal() {
¬†¬†¬†¬†if (revealShown) return;
¬†¬†¬†¬†revealShown = true;
¬†¬†¬†¬†revealOverlay.classList.add('visible');
¬†¬†}

¬†¬†// --- CHECK LOGIC ----------------------------------------------------------
¬†¬†function handleCheck() {
¬†¬†¬†¬†if (selection.length === 0) {
¬†¬†¬†¬†¬†¬†setMessage("Select letters by tapping or dragging.", "neutral");
¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†}

¬†¬†¬†¬†const coords = selection.map(p => [p.r,p.c]);

¬†¬†¬†¬†if (!spanagramFound && cellsEqualPath(coords, spanagram.path)) {
¬†¬†¬†¬†¬†¬†markSpan();
¬†¬†¬†¬†¬†¬†clearSelection();
¬†¬†¬†¬†¬†¬†setMessage("You found the phrase describing your gift!", "success");
¬†¬†¬†¬†¬†¬†checkWin();
¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†}

¬†¬†¬†¬†for (let word of themeWords) {
¬†¬†¬†¬†¬†¬†if (foundTheme.has(word.id)) continue;
¬†¬†¬†¬†¬†¬†if (cellsEqualPath(coords, word.path)) {
¬†¬†¬†¬†¬†¬†¬†¬†markTheme(word);
¬†¬†¬†¬†¬†¬†¬†¬†clearSelection();
¬†¬†¬†¬†¬†¬†¬†¬†setMessage("You found a hidden word!", "success");
¬†¬†¬†¬†¬†¬†¬†¬†checkWin();
¬†¬†¬†¬†¬†¬†¬†¬†return;
¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†}

¬†¬†¬†¬†clearSelection();
¬†¬†¬†¬†setMessage("Not a hidden word ‚Äî try again!", "error");
¬†¬†}

¬†¬†function checkWin() {
¬†¬†¬†¬†if (spanagramFound && foundTheme.size === themeWords.length) {
¬†¬†¬†¬†¬†¬†setMessage("You solved the puzzle! Your gift is a COZY GETAWAY üéÅ", "success");
¬†¬†¬†¬†¬†¬†showGiftReveal();
¬†¬†¬†¬†}
¬†¬†}

¬†¬†// --- THEME TOGGLE ---------------------------------------------------------
¬†¬†let currentTheme = 'cozy';

¬†¬†function applyTheme() {
¬†¬†¬†¬†document.body.classList.remove('cozy','festive');
¬†¬†¬†¬†document.body.classList.add(currentTheme);
¬†¬†¬†¬†if (currentTheme === 'cozy') {
¬†¬†¬†¬†¬†¬†themeToggleBtn.textContent = "Switch to Festive Theme";
¬†¬†¬†¬†} else {
¬†¬†¬†¬†¬†¬†themeToggleBtn.textContent = "Switch to Cozy Theme";
¬†¬†¬†¬†}
¬†¬†}

¬†¬†themeToggleBtn.addEventListener('click', () => {
¬†¬†¬†¬†currentTheme = (currentTheme === 'cozy') ? 'festive' : 'cozy';
¬†¬†¬†¬†applyTheme();
¬†¬†});

¬†¬†closeRevealBtn.addEventListener('click', () => {
¬†¬†¬†¬†revealOverlay.classList.remove('visible');
¬†¬†});

¬†¬†revealOverlay.addEventListener('click', (e) => {
¬†¬†¬†¬†if (e.target === revealOverlay) {
¬†¬†¬†¬†¬†¬†revealOverlay.classList.remove('visible');
¬†¬†¬†¬†}
¬†¬†});

¬†¬†// --- INIT -----------------------------------------------------------------
¬†¬†createSnowflakes(70);
¬†¬†buildGrid();
¬†¬†currentTheme = 'cozy';
¬†¬†applyTheme();
¬†¬†updateSelectionView();
¬†¬†setMessage('Tap or drag to select letters, then tap "Check selection".', 'neutral');

¬†¬†checkBtn.addEventListener('click', handleCheck);
¬†¬†clearBtn.addEventListener('click', () => clearSelection(false));
</script>
</body>
</html>
